
Key management implementation
=============================

This section covers an example implementation of key management. You will learn how to:

* How to use the multi-signature feature on the Casper network end-to-end
* How to create a smart contract and sign transactions with the multi-sig feature

First, download the example contract and client located in `GitHub <https://github.com/casper-ecosystem/keys-manager>`_.

**Begin: THIS SECTION IS WORK IN PROGRESS**

In cargo.toml we have a contract that is a Rust package and is called “keys-manager” and produces a keys-manager wasm file. See target/wasm/release/keys-manager.wasm.

The path is set to src/main.rs, so everything starts on main.rs.

Account code implementation
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The main.rs file takes key_m defined in lib and calls execute.
In lib.rs we have the execute call.

    - lib.rs is the account code
    - a smart contract is a “contract”, it lives somewhere, cannot be changed and is codified and has its own state and can do its own stuff
    - this code is similar to a script that executes something, as your account
    - there is no such context in any other system as of today — this is also new and very useful because you can configure your own account; you can call 2 contracts in a row with 1 call (ex. one call to the first contract, a second call to the second contract.); also if the last instruction fails, everything fails, which can be a very useful feature.
    - Other name could be “session code”.  The name “account code” can be changed. Maybe “account behavior code”
    - In this example, the account code can:
        - 1) add or update a key: 
            - parameters are key, weight
            - the library comes from contract/src/api.rs
            - update associated key: it expects the key to exist for the update call
            - if it doesn’t exist, it will throw a missing key error, and in this case, add the key
        - if the weight is zero in the args, remove the key if it exists
            - if the key doesn’t exists, that is ok, nothing to remove
            - permission denied, threshold violation - not sure how to test this; maybe when you call from within the smart contract — that may not be possible.
        - 2) set action threshold
            - set type and value
            - if an error happens, throw an error


Smart contract example
^^^^^^^^^^^^^^^^^^^^^^

In main, calls execute. When you send a wasm file to the network, the call fcn will be called.
The match statement will do api from arguments — see api.rs; a construct to handle args on the account code side.
The smart c. can do this much better because they have dsl.

If you have a wasm file, you can send it with the arguments and it will do one of the 3 functions in this file. 
Here we have 3 arguments: 
	- action: a string that tells you want you want to do, and get_action_arg will give you the string and then you will match against it. It could be “set weight”, “set deploy thresh”, “set key mgmt thresh”
	- account 
	- weight
See the from_args method.


Key management client example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

keys-manager.js
- nctl network running - local network of 5 nodes
- setup some arguments 
    - cotract wasm file is already compiled to send to the network
    - these are defaults:
        - let nodeUrl = ‘http://localhost:40101/rpc’;
        - let eventStoreUrl = ‘http://localhost:3000';
        - let wasmPath = ‘../contract/target/wasm32-unknown-unknown/release/keys-manager.wasm’;
        - let networkName = ‘casper-net-1’;
    - build a client using CasperClient object - build and add features to it; the main facing piece of the library
    - the network that is running has a special account called faucet with a lot of tokens
    - if you want to interact with the network, you need tokens; you can transfer tokens from this account to your own, or use the faucet account directly in your examples
    - load it based on the path, so adjust it to your own workspace path
    - you will need faucet keys; 2 keys for the example
    - The public and private keys will be generated by nctl. Types of keys Ed* and Sep*. 

In this example: if first and second signed, they have at threshold of 2 and they can use the faucet account to transfer tokens. After the transfer, the first and second keys can be removed.

.. code-block:: sh

 {
	“api_version”: “1.0.0”,
	“merkle_proof”: “01000…..11”,
	“stored_value”: {
		“Account”: {
			“account_hash”: “account-hash-da11…”,
			“action_thresholds”: {
				“deployment”: 2,
				“key_management”: 3
			},
			“associated_keys”: [
				{
					“account_hash”: “account-hash-1…”, // faucet
					“weight”: 3
				},
				{
					“account_hash”: “account-hash-2…”, // deploy account 1
					“weight”: 1
				},
				{
					“account_hash”: “account-hash-3…”, // deploy account 1
					“weight”: 1
				}
			],
			“main_purse”: “uref-1234…”,
			“named_keys”: []
		}
	}
 }

Make a transfer from the faucet using both accounts.
Remove the first account, remove the second account. After removal you have this:

.. code-block:: sh

 {
	“api_version”: “1.0.0”,
	“merkle_proof”: “01000…..11”,
	“stored_value”: {
		“Account”: {
			“account_hash”: “account-hash-da11…”,
			“action_thresholds”: {
				“deployment”: 2,
				“key_management”: 3
			},
			“associated_keys”: [
				{
					“account_hash”: “account-hash-1…”, // faucet
					“weight”: 3
				}
			],
			“main_purse”: “uref-1234…”,
			“named_keys”: []
		}
	}
 }


The buildSetKeyWeightDeploy takes and arg and a weight and uses another function buildKeyManagerDeploy.
About buildKeyManagerDeploy - define who is calling and with what arguments - generic function: 
	- baseAccount: what is the origin you’re using to deploy
	- arguments: who is calling? that will be faucet=baseAccount
	- session: in this case it’s the wasm file; in other cases it could be a hash already deployed
	- create the deploy and call it session
	- the network name nctl-network will be capser-net-1; main net will be hard coded to something else (this script works only with the local network). ** The network name originates in a genesis file, and it’s part of a basic setup of a network.
	- create a module that you’ll be sending
	- define how much you want to pay (the gas)
	- client.makeDeploy (sessionModule = wasm + args)
Use the above buildKeyManagerDeploy for the buildSetKeyWeightDeply, etc.
CLValue - when you pass data as an arg, they have to be encoded as a CL value (the Casper encoding), supporting many types, so it’s handy.

Terminal example of Client
^^^^^^^^^^^^^^^^^^^^^^^^^^

$node src/keys-manager.js


**End: THIS SECTION IS WORK IN PROGRESS**